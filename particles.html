<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand-Controlled 3D Particle System - IKB</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            overflow: hidden;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #video {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 320px;
            height: 240px;
            border: 3px solid #667eea;
            border-radius: 12px;
            z-index: 50;
            transform: scaleX(-1);
            display: none;
        }

        #video.active {
            display: block;
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 100;
            max-width: 300px;
        }

        .controls h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            color: #333;
            font-weight: 600;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .toggle-camera {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 15px;
            transition: opacity 0.3s;
        }

        .toggle-camera:hover {
            opacity: 0.9;
        }

        .toggle-camera.active {
            background: linear-gradient(135deg, #43e97b, #38f9d7);
        }

        .control-group select {
            width: 100%;
            padding: 8px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-family: inherit;
        }

        .color-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .color-btn {
            padding: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s;
            color: white;
            font-size: 0.8rem;
        }

        .color-btn:hover {
            transform: scale(1.05);
        }

        .back-btn {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            text-decoration: none;
            font-weight: 600;
            margin-top: 15px;
            text-align: center;
            transition: opacity 0.3s;
        }

        .back-btn:hover {
            opacity: 0.9;
        }

        .gesture-info {
            background: rgba(102, 126, 234, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #667eea;
        }

        .gesture-info p {
            color: #333;
            font-size: 0.85rem;
            margin-bottom: 5px;
        }

        .gesture-info strong {
            color: #667eea;
        }

        .status {
            text-align: center;
            padding: 8px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 15px;
        }

        .status.detecting {
            background: #d4edda;
            color: #155724;
        }

        .status.waiting {
            background: #fff3cd;
            color: #856404;
        }

        @media (max-width: 768px) {
            .controls {
                left: 10px;
                right: 10px;
                max-width: none;
            }

            #video {
                width: 160px;
                height: 120px;
                top: 10px;
                right: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <video id="video" autoplay playsinline></video>

    <div class="controls">
        <h2>üñêÔ∏è Hand Control</h2>
        
        <button class="toggle-camera" id="cameraToggle">üìπ Start Camera</button>
        
        <div class="status waiting" id="status">Camera Off</div>

        <div class="gesture-info">
            <p><strong>üëã Open Hand:</strong> Expand particles</p>
            <p><strong>‚úä Closed Fist:</strong> Contract particles</p>
            <p><strong>üëÜ Point Up:</strong> Change shape</p>
            <p><strong>‚úåÔ∏è Peace Sign:</strong> Change color</p>
            <p><strong>üëå OK Sign:</strong> Reset view</p>
        </div>
        
        <div class="control-group">
            <label>Shape Template</label>
            <select id="templateSelect">
                <option value="0">Sphere</option>
                <option value="1">Heart ‚ù§Ô∏è</option>
                <option value="2">Saturn ü™ê</option>
                <option value="3">Spiral üåÄ</option>
                <option value="4">Cube üì¶</option>
                <option value="5">Flower üå∏</option>
            </select>
        </div>

        <div class="control-group">
            <label>Color Theme</label>
            <div class="color-buttons">
                <button class="color-btn" style="background: linear-gradient(135deg, #667eea, #764ba2)" onclick="setColor(0)">Blue</button>
                <button class="color-btn" style="background: linear-gradient(135deg, #f093fb, #f5576c)" onclick="setColor(1)">Pink</button>
                <button class="color-btn" style="background: linear-gradient(135deg, #4facfe, #00f2fe)" onclick="setColor(2)">Cyan</button>
                <button class="color-btn" style="background: linear-gradient(135deg, #43e97b, #38f9d7)" onclick="setColor(3)">Green</button>
                <button class="color-btn" style="background: linear-gradient(135deg, #fa709a, #fee140)" onclick="setColor(4)">Sunset</button>
                <button class="color-btn" style="background: linear-gradient(135deg, #30cfd0, #330867)" onclick="setColor(5)">Ocean</button>
            </div>
        </div>

        <a href="projects.html" class="back-btn">‚Üê Back to Projects</a>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    
    <script id="vertex-shader" type="x-shader/x-vertex">
        uniform float u_time;
        uniform float u_templateID;
        uniform float u_gestureIntensity;
        uniform vec3 u_handPos;
        uniform float u_rotationSpeed;

        attribute float a_particleIndex;

        const float PARTICLE_COUNT = 5000.0;

        vec3 heartTemplate(float t) {
            float x = 16.0 * sin(t) * sin(t) * sin(t);
            float y = 13.0 * cos(t) - 5.0 * cos(2.0 * t) - 2.0 * cos(3.0 * t) - cos(4.0 * t);
            float z = sin(t * 5.0) * 2.0;
            return vec3(x * 0.08, y * 0.08 - 1.0, z * 0.08);
        }

        vec3 saturnTemplate(float t, float index) {
            float angle = index * 0.01 + u_time * u_rotationSpeed * 0.2;
            float radius = 3.0 + sin(t * 20.0) * 0.3;
            float x = radius * cos(angle);
            float y = radius * sin(angle);
            float z = sin(index * 0.05) * cos(u_time * 0.3 + index * 0.01) * 0.8;
            return vec3(x, z, y);
        }

        vec3 spiralTemplate(float t, float index) {
            float angle = t * 20.0 + u_time * u_rotationSpeed * 0.3;
            float radius = t * 5.0;
            float x = radius * cos(angle);
            float y = t * 10.0 - 5.0;
            float z = radius * sin(angle);
            return vec3(x, y, z);
        }

        vec3 cubeTemplate(float t, float index) {
            float face = floor(index / (PARTICLE_COUNT / 6.0));
            float localT = fract(index / (PARTICLE_COUNT / 6.0)) * 6.0;
            float u = fract(localT);
            float v = fract(localT * 1.618);
            float size = 3.0;
            
            vec3 pos;
            if (face < 1.0) pos = vec3(u * size - size/2.0, size/2.0, v * size - size/2.0);
            else if (face < 2.0) pos = vec3(u * size - size/2.0, -size/2.0, v * size - size/2.0);
            else if (face < 3.0) pos = vec3(size/2.0, u * size - size/2.0, v * size - size/2.0);
            else if (face < 4.0) pos = vec3(-size/2.0, u * size - size/2.0, v * size - size/2.0);
            else if (face < 5.0) pos = vec3(u * size - size/2.0, v * size - size/2.0, size/2.0);
            else pos = vec3(u * size - size/2.0, v * size - size/2.0, -size/2.0);
            
            float rotY = u_time * u_rotationSpeed * 0.5;
            float cosY = cos(rotY);
            float sinY = sin(rotY);
            pos = vec3(pos.x * cosY - pos.z * sinY, pos.y, pos.x * sinY + pos.z * cosY);
            
            return pos;
        }

        vec3 flowerTemplate(float t, float index) {
            float angle = t * 6.28 + u_time * u_rotationSpeed * 0.2;
            float petals = 8.0;
            float petalAngle = mod(angle * petals, 6.28);
            float radius = 2.0 + sin(petalAngle) * 1.5;
            radius *= (0.5 + t * 0.5);
            
            float x = radius * cos(angle);
            float y = sin(t * 10.0) * 0.5;
            float z = radius * sin(angle);
            return vec3(x, y, z);
        }

        void main() {
            float t = a_particleIndex / PARTICLE_COUNT;
            vec3 finalPos = position;

            if (u_templateID < 0.5) {
                finalPos = position * (1.0 + u_gestureIntensity * 2.0);
            } else if (u_templateID < 1.5) {
                finalPos = heartTemplate(t * 6.28 + u_time * u_rotationSpeed * 0.1);
            } else if (u_templateID < 2.5) {
                finalPos = saturnTemplate(t, a_particleIndex);
            } else if (u_templateID < 3.5) {
                finalPos = spiralTemplate(t, a_particleIndex);
            } else if (u_templateID < 4.5) {
                finalPos = cubeTemplate(t, a_particleIndex);
            } else {
                finalPos = flowerTemplate(t, a_particleIndex);
            }

            finalPos *= (0.5 + u_gestureIntensity * 1.5);

            float dist = distance(finalPos, u_handPos);
            if (dist < 5.0) {
                vec3 attraction = normalize(u_handPos - finalPos) * (5.0 - dist) * 0.3;
                finalPos += attraction;
            }

            vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
            gl_PointSize = (300.0 / -mvPosition.z) * (0.5 + u_gestureIntensity * 0.5);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        uniform float u_colorSwitch;
        uniform vec3 u_colorA;
        uniform vec3 u_colorB;

        void main() {
            vec2 coord = gl_PointCoord - vec2(0.5);
            float r = length(coord);
            
            if (r > 0.5) discard;
            
            float alpha = 1.0 - smoothstep(0.0, 0.5, r);
            alpha = pow(alpha, 2.0);

            vec3 finalColor = mix(u_colorA, u_colorB, u_colorSwitch);
            finalColor += vec3(1.0) * (1.0 - r * 2.0) * 0.3;

            gl_FragColor = vec4(finalColor, alpha);
        }
    </script>

    <script>
        const PARTICLE_COUNT = 5000;
        let scene, camera, renderer, particles;
        let hands, cameraInstance;
        let isCameraActive = false;
        let currentTemplate = 0;
        let currentColorIndex = 0;

        const colorThemes = [
            { a: [0.4, 0.47, 0.92], b: [0.46, 0.29, 0.64] },
            { a: [0.94, 0.58, 0.98], b: [0.96, 0.34, 0.42] },
            { a: [0.31, 0.67, 0.99], b: [0.0, 0.95, 0.99] },
            { a: [0.26, 0.91, 0.48], b: [0.22, 0.98, 0.84] },
            { a: [0.98, 0.44, 0.60], b: [0.99, 0.88, 0.25] },
            { a: [0.19, 0.81, 0.82], b: [0.20, 0.03, 0.40] }
        ];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 10;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 1);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const particleIndices = [];

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 3;
                
                positions.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                particleIndices.push(i);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('a_particleIndex', new THREE.Float32BufferAttribute(particleIndices, 1));

            const uniforms = {
                u_time: { value: 0 },
                u_templateID: { value: 0 },
                u_handPos: { value: new THREE.Vector3(0, 0, 0) },
                u_gestureIntensity: { value: 0.5 },
                u_colorSwitch: { value: 0.0 },
                u_colorA: { value: new THREE.Vector3(...colorThemes[0].a) },
                u_colorB: { value: new THREE.Vector3(...colorThemes[0].b) },
                u_rotationSpeed: { value: 0.3 }
            };

            const material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vertex-shader').textContent,
                fragmentShader: document.getElementById('fragment-shader').textContent,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthTest: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            document.getElementById('templateSelect').addEventListener('change', (e) => {
                currentTemplate = parseFloat(e.target.value);
                particles.material.uniforms.u_templateID.value = currentTemplate;
            });

            document.getElementById('cameraToggle').addEventListener('click', toggleCamera);
            window.addEventListener('resize', onWindowResize);
        }

        async function toggleCamera() {
            const btn = document.getElementById('cameraToggle');
            const video = document.getElementById('video');
            const status = document.getElementById('status');

            if (!isCameraActive) {
                try {
                    await initializeHandTracking();
                    btn.textContent = 'üìπ Stop Camera';
                    btn.classList.add('active');
                    video.classList.add('active');
                    status.textContent = '‚úã Hand Detected';
                    status.className = 'status detecting';
                    isCameraActive = true;
                } catch (error) {
                    console.error('Camera error:', error);
                    status.textContent = '‚ùå Camera Error';
                    status.className = 'status waiting';
                    alert('Could not access camera. Please allow camera permissions.');
                }
            } else {
                stopCamera();
                btn.textContent = 'üìπ Start Camera';
                btn.classList.remove('active');
                video.classList.remove('active');
                status.textContent = 'Camera Off';
                status.className = 'status waiting';
                isCameraActive = false;
            }
        }

        async function initializeHandTracking() {
            hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandResults);

            const video = document.getElementById('video');
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: 'user' } 
            });
            video.srcObject = stream;

            cameraInstance = new Camera(video, {
                onFrame: async () => {
                    await hands.send({ image: video });
                },
                width: 640,
                height: 480
            });

            cameraInstance.start();
        }

        function stopCamera() {
            if (cameraInstance) {
                cameraInstance.stop();
            }
            const video = document.getElementById('video');
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
            }
        }

        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                const palmBase = landmarks[0];
                const x = (palmBase.x - 0.5) * 20;
                const y = -(palmBase.y - 0.5) * 20;
                const z = -palmBase.z * 10;
                
                particles.material.uniforms.u_handPos.value.set(x, y, z);

                const gesture = recognizeGesture(landmarks);
                handleGesture(gesture);
            }
        }

        function recognizeGesture(landmarks) {
            const thumb_tip = landmarks[4];
            const index_tip = landmarks[8];
            const middle_tip = landmarks[12];
            const ring_tip = landmarks[16];
            const pinky_tip = landmarks[20];
            const wrist = landmarks[0];

            const thumbUp = thumb_tip.y < wrist.y;
            const indexUp = index_tip.y < wrist.y;
            const middleUp = middle_tip.y < wrist.y;
            const ringUp = ring_tip.y < wrist.y;
            const pinkyUp = pinky_tip.y < wrist.y;

            const fingersUp = [thumbUp, indexUp, middleUp, ringUp, pinkyUp].filter(f => f).length;

            const thumbIndexDist = Math.hypot(
                thumb_tip.x - index_tip.x,
                thumb_tip.y - index_tip.y
            );

            if (fingersUp === 5) return 'open_hand';
            if (fingersUp === 0) return 'closed_fist';
            if (indexUp && !middleUp && !ringUp && !pinkyUp) return 'point_up';
            if (indexUp && middleUp && !ringUp && !pinkyUp) return 'peace';
            if (thumbIndexDist < 0.05) return 'ok_sign';
            
            return 'neutral';
        }

        let lastGestureTime = 0;
        const gestureDelay = 1000;

        function handleGesture(gesture) {
            const now = Date.now();
            
            if (gesture === 'open_hand') {
                particles.material.uniforms.u_gestureIntensity.value = 1.0;
            } else if (gesture === 'closed_fist') {
                particles.material.uniforms.u_gestureIntensity.value = 0.1;
            } else if (gesture === 'point_up' && now - lastGestureTime > gestureDelay) {
                currentTemplate = (currentTemplate + 1) % 6;
                particles.material.uniforms.u_templateID.value = currentTemplate;
                document.getElementById('templateSelect').value = currentTemplate;
                lastGestureTime = now;
            } else if (gesture === 'peace' && now - lastGestureTime > gestureDelay) {
                currentColorIndex = (currentColorIndex + 1) % 6;
                setColor(currentColorIndex);
                lastGestureTime = now;
            } else if (gesture === 'ok_sign' && now - lastGestureTime > gestureDelay) {
                particles.rotation.set(0, 0, 0);
                camera.position.set(0, 0, 10);
                lastGestureTime = now;
            } else if (gesture === 'neutral') {
                particles.material.uniforms.u_gestureIntensity.value = 0.5;
            }
        }

        function setColor(index) {
            particles.material.uniforms.u_colorA.value.set(...colorThemes[index].a);
            particles.material.uniforms.u_colorB.value.set(...colorThemes[index].b);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            particles.material.uniforms.u_time.value += 0.01;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
